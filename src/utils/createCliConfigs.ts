import * as core from '@actions/core';
import * as fs from 'fs';
import * as path from 'path';
import { ActionConfig } from '../config/config.js';

/**
 * Creates CLI configuration files to control context and file access for Claude Code and Codex.
 * This is the proper way to limit what files and context the CLIs can access.
 */

/**
 * Creates a CLAUDE.md file with project context and guidelines
 * Claude Code automatically reads this file for project-specific context
 */
export function createClaudeConfig(workspace: string, config: ActionConfig): void {
  const claudeMdPath = path.join(workspace, 'CLAUDE.md');
  
  // Don't overwrite existing CLAUDE.md
  if (fs.existsSync(claudeMdPath)) {
    core.info('CLAUDE.md already exists, skipping creation');
    return;
  }

  const claudeContent = `# Claude Code Project Configuration

## Context Limits
${config.maxContextTokens ? `- Maximum context tokens: ${config.maxContextTokens}` : ''}
${config.maxHistoryComments ? `- Maximum history comments: ${config.maxHistoryComments}` : ''}
${config.maxChangedFilesInContext ? `- Maximum changed files in context: ${config.maxChangedFilesInContext}` : ''}

## File Filtering Guidelines
${config.includePatterns?.length ? `- Include patterns: ${config.includePatterns.join(', ')}` : ''}
${config.excludePatterns?.length ? `- Exclude patterns: ${config.excludePatterns.join(', ')}` : ''}

## Instructions
- Focus on the most relevant files for the current task
- Prioritize recently changed files when making modifications
- Follow existing code patterns and conventions
- Add appropriate error handling and logging
- Write comprehensive tests for new functionality

## Repository Guidelines
- Use TypeScript for all new code
- Follow existing import patterns
- Maintain consistency with current architecture
- Add JSDoc comments for new functions
- Run tests before making changes

---
*This file was auto-generated by GitHub Actions. Modify as needed for your project.*
`;

  try {
    fs.writeFileSync(claudeMdPath, claudeContent, 'utf8');
    core.info('Created CLAUDE.md with project context and limits');
  } catch (error) {
    core.warning(`Failed to create CLAUDE.md: ${error}`);
  }
}

/**
 * Creates .claude/settings.json file for Claude Code configuration
 * This controls file access patterns and context limits at the CLI level
 */
export function createClaudeSettingsFile(workspace: string, config: ActionConfig): void {
  const claudeDir = path.join(workspace, '.claude');
  const settingsPath = path.join(claudeDir, 'settings.json');

  // Create .claude directory if it doesn't exist
  try {
    fs.mkdirSync(claudeDir, { recursive: true });
  } catch (error) {
    core.warning(`Failed to create .claude directory: ${error}`);
    return;
  }

  const settings = {
    // File filtering settings
    ...(config.includePatterns?.length && { includePatterns: config.includePatterns }),
    ...(config.excludePatterns?.length && { excludePatterns: config.excludePatterns }),
    
    // Context limits
    ...(config.maxContextTokens && { maxContextTokens: config.maxContextTokens }),
    ...(config.enableContextTruncation && { enableContextTruncation: config.enableContextTruncation }),
    
    // Codebase filtering
    ...(config.maxCodebaseFiles && { maxCodebaseFiles: config.maxCodebaseFiles }),
    ...(config.maxCodebaseSizeBytes && { maxCodebaseSizeBytes: config.maxCodebaseSizeBytes }),
    ...(config.enableCodebaseFiltering && { enableCodebaseFiltering: config.enableCodebaseFiltering }),
    ...(config.prioritizeRecentFiles && { prioritizeRecentFiles: config.prioritizeRecentFiles }),
  };

  try {
    fs.writeFileSync(settingsPath, JSON.stringify(settings, null, 2), 'utf8');
    core.info('Created .claude/settings.json with filtering configuration');
  } catch (error) {
    core.warning(`Failed to create Claude settings file: ${error}`);
  }
}

/**
 * Creates .codexignore file to control which files Codex should ignore
 * This is similar to .gitignore but specifically for Codex
 */
export function createCodexIgnoreFile(workspace: string, config: ActionConfig): void {
  const codexIgnorePath = path.join(workspace, '.codexignore');
  
  // Don't overwrite existing .codexignore
  if (fs.existsSync(codexIgnorePath)) {
    core.info('.codexignore already exists, skipping creation');
    return;
  }

  const ignorePatterns = [
    '# Auto-generated .codexignore file',
    '# Large directories',
    'node_modules/',
    'dist/',
    'build/',
    '.cache/',
    '.next/',
    'coverage/',
    '.nyc_output/',
    '',
    '# Binary files',
    '*.exe',
    '*.dll',
    '*.so',
    '*.dylib',
    '*.zip',
    '*.tar.gz',
    '*.7z',
    '',
    '# Media files',
    '*.jpg',
    '*.jpeg',
    '*.png',
    '*.gif',
    '*.mp4',
    '*.mp3',
    '',
    '# Log files',
    '*.log',
    'logs/',
    '',
    '# Temporary files',
    '*.tmp',
    '*.temp',
    '.DS_Store',
    'Thumbs.db',
    ''
  ];

  // Add custom exclude patterns
  if (config.excludePatterns?.length) {
    ignorePatterns.push('# Custom exclude patterns');
    ignorePatterns.push(...config.excludePatterns);
    ignorePatterns.push('');
  }

  try {
    fs.writeFileSync(codexIgnorePath, ignorePatterns.join('\n'), 'utf8');
    core.info('Created .codexignore with file filtering patterns');
  } catch (error) {
    core.warning(`Failed to create .codexignore: ${error}`);
  }
}

/**
 * Creates AGENTS.md file with instructions for Codex
 */
export function createCodexConfig(workspace: string, config: ActionConfig): void {
  const agentsMdPath = path.join(workspace, 'AGENTS.md');
  
  // Don't overwrite existing AGENTS.md
  if (fs.existsSync(agentsMdPath)) {
    core.info('AGENTS.md already exists, skipping creation');
    return;
  }

  const agentsContent = `# Codex Agent Instructions

## Context Limits
${config.maxContextTokens ? `- Maximum context tokens: ${config.maxContextTokens}` : ''}
${config.maxCodebaseFiles ? `- Maximum files to consider: ${config.maxCodebaseFiles}` : ''}
${config.maxCodebaseSizeBytes ? `- Maximum codebase size: ${Math.round(config.maxCodebaseSizeBytes / 1024 / 1024)}MB` : ''}

## File Handling
- Prioritize files relevant to the current task
- Ignore files listed in .codexignore
- Focus on source code files over configuration
${config.prioritizeRecentFiles ? '- Prioritize recently modified files' : ''}

## Code Guidelines
- Maintain existing code style and patterns
- Add minimal but effective comments
- Follow TypeScript best practices
- Ensure type safety
- Write clean, readable code

## Testing
- Add unit tests for new functionality
- Follow existing test patterns
- Ensure tests pass before completion

---
*This file was auto-generated by GitHub Actions. Customize for your project needs.*
`;

  try {
    fs.writeFileSync(agentsMdPath, agentsContent, 'utf8');
    core.info('Created AGENTS.md with Codex instructions and limits');
  } catch (error) {
    core.warning(`Failed to create AGENTS.md: ${error}`);
  }
}

/**
 * Creates all necessary CLI configuration files
 */
export function createAllCliConfigs(workspace: string, config: ActionConfig): void {
  core.info('Creating CLI configuration files for context and file limiting...');
  
  try {
    // Claude Code configurations
    createClaudeConfig(workspace, config);
    createClaudeSettingsFile(workspace, config);
    
    // Codex configurations
    createCodexConfig(workspace, config);
    createCodexIgnoreFile(workspace, config);
    
    core.info('CLI configuration files created successfully');
  } catch (error) {
    core.error(`Failed to create CLI configurations: ${error}`);
  }
}

/**
 * Cleanup function to remove auto-generated config files
 */
export function cleanupCliConfigs(workspace: string): void {
  const filesToCleanup = [
    path.join(workspace, 'CLAUDE.md'),
    path.join(workspace, 'AGENTS.md'),
    path.join(workspace, '.codexignore'),
    path.join(workspace, '.claude', 'settings.json')
  ];

  for (const filePath of filesToCleanup) {
    try {
      if (fs.existsSync(filePath)) {
        // Check if file has auto-generated marker
        const content = fs.readFileSync(filePath, 'utf8');
        if (content.includes('auto-generated by GitHub Actions')) {
          fs.unlinkSync(filePath);
          core.debug(`Cleaned up auto-generated file: ${filePath}`);
        }
      }
    } catch (error) {
      core.debug(`Failed to cleanup ${filePath}: ${error}`);
    }
  }

  // Try to remove .claude directory if empty
  try {
    const claudeDir = path.join(workspace, '.claude');
    if (fs.existsSync(claudeDir)) {
      const files = fs.readdirSync(claudeDir);
      if (files.length === 0) {
        fs.rmdirSync(claudeDir);
        core.debug('Removed empty .claude directory');
      }
    }
  } catch (error) {
    core.debug(`Failed to remove .claude directory: ${error}`);
  }
}